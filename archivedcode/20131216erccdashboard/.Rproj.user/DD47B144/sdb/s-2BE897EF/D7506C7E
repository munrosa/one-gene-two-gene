{
    "contents" : "testDE<- function(sampleInfo, expDat, cnt = cnt, info = info){\n  library(QuasiSeq)\n  #library(DESeq)\n  library(edgeR)\n  \n  filenameRoot = sampleInfo$filenameRoot\n  legendLabels = sampleInfo$legendLabels\n  FCcode = sampleInfo$FCcode\n  totalSeqReads = sampleInfo$totalSeqReads\n  \n  \n  idCols = expDat$idColsAdj\n  r_m.mn = expDat$r_m.res$r_m.mn \n  totalReads = expDat$totalReads \n  sample1 = expDat$sampleNames[1]\n  sample2 = expDat$sampleNames[2]\n  \n  #Create a custom color scale\n  myColors <- c(\"#339966\",\"#FF9900\", \"#6699CC\", \"#CC6666\")\n  names(myColors) <- levels(FCcode$Ratio)\n  colScale <- scale_colour_manual(name = \"Ratio\",values = myColors, labels = legendLabels)\n  fillScale <- scale_fill_manual(name = \"Ratio\", values = myColors, labels = legendLabels)\n  #Move legend\n  theme_update(legend.justification=c(1,1), legend.position=c(1,1))\n  \n  cnt = unique(cnt)\n  Features = make.names(cnt$Feature,unique=T)\n  Features = gsub(\".\",\"-\", Features, fixed = T)\n  #print(str(cnt))\n  #print(dim(cnt))\n  rownames(cnt)<-Features; cnt<-as.matrix(cnt[,-1])\n  \n  colnames(cnt)<-paste(rep(c(sample1,sample2),each=ncol(cnt)/2),c(1:(ncol(cnt)/2),1:(ncol(cnt)/2)),sep=\"\")\n  ## Get ERCC names\n  ERCC<-rownames(cnt[substr(rownames(cnt),1,5)==\"ERCC-\",])\n  \n  ## Specify Sample (A or B)\n  trt<-rep(1:2,each=ncol(cnt)/2)\n  \n  design.list<-list(trt,rep(1,ncol(cnt)))\n  \n  ## Compute offset (e.g. total counts, 75% quantile, TMM, etc)\n  if(totalSeqReads == F){\n    log.offset<-log(colSums(cnt))\n    cat(\"\\nUsing Mapped Reads\\n\")\n    cat(colSums(cnt),\"\\n\")  \n  }else{\n    log.offset<- log(totalReads)\n    cat(\"\\nUsing Total Reads\\n\")\n    cat(totalReads,\"\\n\")\n  }\n  \n  ERCC.FC = idCols[c(1,4)];rownames(ERCC.FC)<-ERCC.FC[,1]\n  \n  ERCC.FC$NumRatio <- 1\n  for (i in 1:nlevels(FCcode$Ratio)){\n    ERCC.FC$NumRatio[which(ERCC.FC$Ratio == as.character(FCcode$Ratio[i]))] = FCcode$FC[i]  \n  }\n  ERCC.Ratio = ERCC.FC[c(1,2)]\n  ERCC.FC = ERCC.FC[-c(2)]\n    \n  group <- as.factor(trt)\n  d <- DGEList(counts=cnt,group=group)\n  # use log.offset for the library size\n  d$samples$lib.size <- exp(log.offset) \n  #print(d$samples$lib.size)\n  #Dispersion trend\n  design <- model.matrix(~group)\n  d1 <- estimateGLMCommonDisp(d,design,verbose=TRUE)\n  d1 <- estimateGLMTrendedDisp(d1,design)\n  d1 <- estimateGLMTagwiseDisp(d1,design)\n\n  #######################################################\n  ###  Simulate ERCC data from negative binomial fit ####\n  ###  (to be used for sim-based LODR)               ####\n  #######################################################\n  # Define function simcnt.lodr\n  simcnt.lodr<-function(cnt,disp,trt,fold,log.offset){\n    #### 'cnt' is the matrix of counts for endogenous genes\n    #### 'disp' is the central trend fitted to the estimated dispersions (vs. expression)\n    #### 'trt' is a vector specifying to which treatment each column in 'cnt' belongs\n    #### 'fold' is the desired fold change (trt 2/trt 1)\n    #### 'log.offset' is used to account for differences in library size\n    \n    sim.ind<-round(nrow(cnt)*c(1:49)/50)  ### mimick every 797th gene (roughly), when sorted by total count\n    norm.cnt<-t(t(cnt)/exp(log.offset))\n    sim.mn<-matrix(sort(rowMeans(norm.cnt))[sim.ind],nrow=length(sim.ind),ncol=ncol(cnt))\n    sim.mn<-sim.mn*2/(1+fold)\n    sim.mn[,trt==2]<-sim.mn[,trt==2]*fold\n    sim.mn<-t(t(sim.mn)*exp(log.offset))\n    \n    sim.disp<-disp[order(rowMeans(norm.cnt))][sim.ind]\n    size<-matrix(1/sim.disp,length(sim.disp),ncol(cnt))\n    simcnt<-matrix(rnbinom(length(sim.disp)*ncol(cnt),mu=sim.mn,size=size),length(sim.disp),ncol(cnt))\n    rownames(simcnt)<-paste(\"Sim\",fold,\"Fold\",1:length(sim.ind),sep=\"\")\n    return(simcnt)\n  }\n  \n  #### Simulate data for each of the fold changes used in the ERCCs\n  simcnt<-NULL\n  for(fold in unique(ERCC.FC[!is.na(ERCC.FC[,2]),2])){\n    #simcnt<-rbind(simcnt,simcnt.lodr(cnt,disp=fitInfo(cds)$fittedDispEsts,trt=trt,fold=fold,log.offset=log.offset))\n    simcnt<-rbind(simcnt,simcnt.lodr(cnt,disp=d1$trended.dispersion,trt=trt,fold=fold,log.offset=log.offset))\n  }\n  \n  ##### Analyze combination of observed and simulated data with edgeR\n  group <- as.factor(trt)\n  d2 <- DGEList(counts=rbind(cnt,simcnt),group=group)\n  d2$samples$lib.size <- exp(log.offset)\n  \n  design <- model.matrix(~group)\n  d2 <- estimateGLMCommonDisp(d2,design,verbose=TRUE)\n  d2 <- estimateGLMTrendedDisp(d2,design)\n  d2 <- estimateGLMTagwiseDisp(d2,design)\n \n  NBdisp<-d2$tagwise.dispersion;names(NBdisp)<-rownames(rbind(cnt,simcnt))\n  NBdisptrend<-d2$trended.dispersion;names(NBdisptrend)<-rownames(rbind(cnt,simcnt))\n  \n  ### Plot estimated dispersions \n  dispcnt = data.frame(x = rowMeans(rbind(cnt,simcnt)), y = NBdisp)\n  dispSimcnt = data.frame(xsim = rowMeans(simcnt), ysim = NBdisp[-c(1:nrow(cnt))])\n  dispERCCcnt = data.frame(xERCC = rowMeans(cnt)[ERCC],yERCC = NBdisp[ERCC])\n  \n  dispPlot = ggplot(dispcnt) + geom_point(aes(x = x, y = y)) + scale_x_log10()+ xlab(\"Average Count\") + ylab(\"Estimated Dispersion\") + geom_point(data = dispSimcnt,aes(x = xsim, y = ysim),colour = 3) + geom_point(data = dispERCCcnt, aes(x = xERCC, y = yERCC),colour = 2)\n   #print(dispPlot) \n  \n  ### Run QuasiSeq\n  use.fit<-QL.fit(rbind(cnt,simcnt),design.list,log.offset=log.offset,NBdisp=NBdisptrend)# using trended dispersion from edgeR\n  use.res<-QL.results(use.fit, Plot = F)\n  \n  useRescnt <- data.frame(use.res$P.values) ### added to allow next command to access the Spline P-values\n  \n  ### Collect results for simulated data; to be passed along to LODR function\n  sim.pval.res<-cbind(row.names(simcnt), rowMeans(simcnt),use.res$P.values$QLSpline[-(1:nrow(cnt))],use.res$log.P.values$QLSpline[-(1:nrow(cnt))],use.res$F.stat$QLSpline[-(1:nrow(cnt))],\n  rep(unique(ERCC.FC[!is.na(ERCC.FC[,2]),2]),each=49),rep(use.res$d0[2],nrow(simcnt)))\n  colnames(sim.pval.res)<-c(\"Feature\",\"MnCnt\",\"Pval\",\"LogPval\",\"F.stat\",\"Fold\",\n                            \"Den.df\")\n  rownames(sim.pval.res)<-rownames(simcnt)\n\n  write.csv(sim.pval.res,file=paste(filenameRoot,\"Sim Pvals.csv\"))\n  \n  ## remove results for simulated data\n  use.fit2<-use.fit\n  use.fit2$LRT<-matrix(use.fit2$LRT[1:nrow(cnt),],nrow(cnt),1)\n  use.fit2$phi.hat.dev<-use.fit2$phi.hat.dev[1:nrow(cnt)]\n  use.fit2$phi.hat.pearson<-use.fit2$phi.hat.pearson[1:nrow(cnt)]\n  use.fit2$mn.cnt<-use.fit2$mn.cnt[1:nrow(cnt)]\n  use.fit2$NB.disp<-use.fit2$NB.disp[1:nrow(cnt)]\n  use.fit2$fitted.values<-use.fit2$fitted.values[1:nrow(cnt),]\n  use.fit2$coefficients<-use.fit2$coefficients[1:nrow(cnt),]\n  \n  use.res2<-QL.results(use.fit2, Plot = F)\n  \n  ###################################\n  #### Examine results for ERCCs ####\n  ###################################\n  pvals<-use.res2$P.values$QLSpline\n  names(pvals)<-rownames(cnt)\n  ERCC.pvals<-pvals[ERCC]\n  \n  rownames(use.fit2$coefficients)<-rownames(cnt)\n  est.FC<-use.fit2$coefficients[ERCC,2]\n  \n  ## Reanalyze ERCC transcripts using adjusted offsets to center fold change estimates\n  adj <- r_m.mn #### Use r_m estimated from NegBin GLM\n  use.fit.adj<-QL.fit(cnt[ERCC,],design.list,log.offset=log.offset-rep(c(adj,0),each=ncol(cnt)/2),NBdisp=NBdisptrend[ERCC])\n\n  rownames(use.fit.adj$coefficients)<-ERCC;\n  est.FC.adj<-use.fit.adj$coefficients[ERCC,2]\n  use.fit3<-use.fit2\n  rownames(use.fit3$LRT)<-rownames(cnt);use.fit3$LRT[ERCC,]<-use.fit.adj$LRT\n  use.res.adj<-QL.results(use.fit3, Plot = F)\n\n  pvals<-use.res.adj$P.values$QLSpline\n\n  log.pvals<-use.res.adj$log.P.values$QLSpline\n  F.stat<-use.res.adj$F.stat$QLSpline\n  names(F.stat)<-names(log.pvals)<-names(pvals)<-rownames(cnt)\n\n  qvals<-use.res.adj$Q.values$QLSpline\n  quasiSeq.res = data.frame(Feature = names(pvals), pvals = pvals, qvals = qvals, log.pvals=log.pvals, F.stat=F.stat, den.df=rep(use.res.adj$d0[2], length(pvals)))  \n\n  write.csv(quasiSeq.res, file = paste(filenameRoot,\"quasiSeq.res.csv\",sep=\".\"),row.names = F)\n  \n  ERCC.pvals.adj<-pvals[ERCC]\n  ERCC.F.stat.adj<-F.stat[ERCC]\n  ERCC.log.pvals.adj<-log.pvals[ERCC]\n\n  ### Collect results for ERCCs; to be passed along to LODR function\n  pval.res<-data.frame(row.names(cnt[ERCC,]),rowMeans(cnt[ERCC,]),ERCC.pvals.adj,ERCC.log.pvals.adj,ERCC.F.stat.adj,ERCC.FC[ERCC,2],rep(use.res.adj$d0[2],length(ERCC.pvals.adj)))\n  colnames(pval.res)<-c(\"Feature\",\"MnCnt\",\"Pval\",\"LogPval\",\"F.stat\",\"Fold\",\n                        \"Den.df\")\n  print(str(pval.res))\n  row.names(pval.res) <- NULL\n  write.csv(pval.res,file=paste(filenameRoot,\"ERCC Pvals.csv\"))\n  print(\"Finished DE testing\")\n  \n  expDat$quasiSeq.res <- quasiSeq.res\n  expDat$ERCCpvals <- pval.res\n  #################################################\n  ###Examine ERCC blending with endogenous genes###\n  #################################################\n  \n  ### Plot estimated dispersions and central trend estimates ###\n  \n  NBdisp1 <- d1$tagwise.dispersion;names(NBdisp1)<-rownames(cnt) # use tagwise\n  NBdisp2<-d1$trended.dispersion;names(NBdisp2)<-rownames(cnt) # use trended?\n\n  dispcnt = data.frame(Feature = rownames(cnt), x = rowMeans(cnt), y = NBdisp1)\n  dispcntSort = data.frame(xsort = sort(rowMeans(cnt)), ysort = NBdisp2[order(rowMeans(cnt))])\n    \n  dispERCCcnt = data.frame(meanCnt = rowMeans(cnt)[ERCC],disp = NBdisp1[ERCC], Ratio = ERCC.Ratio$Ratio[match(ERCC,ERCC.Ratio$Feature)] )\n  dispERCCcnt$Ratio <- as.factor(dispERCCcnt$Ratio) \n  \n  dispPlot = ggplot(dispcnt) +  geom_point(data = dispcnt, aes(x = x, y = y),colour = \"grey85\",size = 5, alpha = 0.6) + geom_point(data = dispERCCcnt, aes(x = meanCnt, y = disp, colour = Ratio), size = 5, alpha = 0.6) + xlab(\"Mean Counts\") + ylab(\"Negative Binomial Dispersion\") + stat_smooth(data = dispcntSort,aes(x = xsort, y = ysort),colour = \"black\", alpha = 0.8)  + colScale + scale_x_log10()\n  #print(dispPlot)\n  \n  \n  phi.hat<-use.fit$phi.hat.dev[1:nrow(cnt)]\n  mn.cnt<-rowMeans(cnt);den.df=length(trt)-length(unique(trt))\n  y<-log(phi.hat);names(y)<-rownames(cnt); y[y==-Inf]<-min(y[y!=-Inf]); y[y==Inf]<-max(y[y!=Inf])\n  spline.fit<-sreg(log(mn.cnt), y)\n  fit.method<-\"spline\"\n  \n  if(spline.fit$eff.df==0){\n    fit.method<-\"locfit curve\"\n    print(\"Spline fitting failed.  Using locfit instead.\")\n    fit<-locfit(y~lp(log(mn.cnt)))\n    spline.fit<-list(fitted.values=predict(fit,newdata=log(mn.cnt)),eff.df=fit$dp[\"df1\"])\n  }\n  \n  ### We use Smyth's (2004) approach from LIMMA to estimate parameters for prior distributions \n  ### of gene specific dispersion estimates. The function below also provides resulting \n  ### shrunken point estimates of dispersion \n  \n  #### Code for implementing Smyth's approach begins here ####\n  shrink.phi<-function(phi.hat,den.df){\n    phi.hat[phi.hat<=0]<-min(phi.hat[phi.hat>0])\n    z<-log(phi.hat); z[z==Inf]<-max(z[z!=Inf]); z[z==-Inf]<-min(z[z!=-Inf]);mnz<-mean(z)\n    \n    ## solve for d0 and phi0\n    d0arg<-var(z)-trigamma((den.df)/2)\n    if(d0arg>0){\n      dif<-function(x,y) abs(trigamma(x)-y)\n      inverse.trigamma<-function(y) optimize(dif,interval=c(0,10000),y=y)$minimum\n      d0<-2*inverse.trigamma(d0arg)\n      phi0<-exp(mnz-digamma((den.df)/2)+digamma(d0/2)- log(d0/(den.df)))\n      \n      ## compute shrunken phi's\n      phi.shrink<-((den.df)*phi.hat+d0*phi0)/(den.df+d0)  }\n    else{phi.shrink<-rep(exp(mnz),length(z)); d0<-Inf; phi0<-exp(mnz) }\n    return(list(phi.shrink=phi.shrink,d0=d0,phi0=phi0))  }\n  #### Code for implementing Smyth's approach ends here ####\n  \n  ### Obtain estimate for prior degrees of freedom and scaling factor after adjusting for cubic spline fit\n  y2<-phi.hat/exp(spline.fit$fitted.values)\n  shrink<-shrink.phi(y2,den.df)\n  D0<-shrink[[2]]; \n  phi0<-shrink[[3]]; print(paste(\"Spline scaling factor:\",phi0))\n  \n  ### plot the resulting cubic spline fit\n  #mean = log(mn.cnt)\n  mean = mn.cnt\n  dispcnt = data.frame(mean = mean,y = y)\n  dispcntSort = data.frame(xsort = sort(mean), ysort = spline.fit$fitted.values[order(mn.cnt)])\n  dispERCC = data.frame(mean = mean[ERCC],y = y[ERCC], Ratio= ERCC.Ratio$Ratio[match(ERCC,ERCC.Ratio$Feature)] )\n  dispERCC$Ratio <- as.factor(dispERCC$Ratio) \n  \n  ###Compare quantiles from estimated theoretical and empirical dispersion distributions\n  RR<-NULL; sort.mn<-log(sort(mn.cnt)); qq<-c(.05,.95);ord.F<-y[order(mn.cnt)]\n  bins<-c(1+round(length(y)*(0:19)/20),length(y))\n  for(ii in 1:(length(bins)-1)){\n    ind<-bins[ii]:bins[ii+1]\n    RR<-rbind(RR,c(quantile(ord.F[ind],qq),median(sort.mn[ind])))\n  }\n  dispcntInterval = data.frame(x=sort(log(mn.cnt)),upperY = spline.fit$fitted.values[order(mn.cnt)]+log(phi0*qf(.95,den.df,D0)), lowerY =spline.fit$fitted.values[order(mn.cnt)]+log(phi0*qf(.05,den.df,D0)) )\n  \n  dispcntRR = data.frame(x = RR[,3], upperY = RR[,2], lowerY = RR[,1])\n  \n  quasiDispPlot = ggplot() + geom_point(data = dispcnt, aes(x = mean, y = y),colour = \"grey85\", size = 5, alpha = 0.6) + geom_point(data = dispERCC, aes(x = mean, y = y,colour = Ratio), size = 5, alpha = 0.6) + xlab(\"Mean Counts\") + ylab(\"log(Quasi Dispersion)\") + stat_smooth(data = dispcntSort,aes(x = xsort, y = ysort),colour = \"black\") + scale_x_log10() + colScale\n  expDat$Figures$dispPlot <- quasiDispPlot\n  #save(quasiDispPlot, file=paste(filenameRoot,\"DispPlot.RData\", sep = \".\"))\n  cat(\"\\nFinished examining dispersions\\n\")\n  return(expDat)\n\n}",
    "created" : 1387221953428.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4046028370",
    "id" : "D7506C7E",
    "lastKnownWriteTime" : 1386478796,
    "path" : "~/Documents/NISTMunro/Projects/erccdashboard/R/testDE.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}